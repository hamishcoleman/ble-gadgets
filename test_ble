#!/usr/bin/env python
#
# Simple test script to try and interact with BLE devices
#

import argparse

import dbus
import struct
import time

def dbus2float32t(array):
    """Dbus returns us a "dbus.Array", we want the float from inside that
    """
    s = ''
    for ch in array:
        s += chr(ch)
    return (struct.unpack('<f',s))[0]

def dbus2uint8t(array):
    return int(array[0])

def dbus2unknown(object):
    return object

gatt_list = {
    'unknown': {
        'func': dbus2unknown,
        'desc': 'Unknown',
    },
    '00002a19-0000-1000-8000-00805f9b34fb': {
        'func': dbus2uint8t,
        'desc': 'Battery',
    },
    '00002235-b38d-4985-720e-0f993a68ee41': {
        'func': dbus2float32t,
        'desc': 'Temperature',
    },
    '00001235-b38d-4985-720e-0f993a68ee41': {
        'func': dbus2float32t,
        'desc': 'Humidity',
    },
}


class Characteristic:
    """Representing a GATT characteristic
    """

    def __init__(self, bus, prop, path):
        # FIXME - there should only be one instance for any path, we should
        # keep a class dictionary and return refs to existing objects
        # if found

        self.path = path
        self.prop = prop

        proxy = bus.get_object('org.bluez',path)
        self.char = dbus.Interface(proxy,
                              dbus_interface="org.bluez.GattCharacteristic1")

        # properties that will not change
        self.uuid = self.prop.Get(self.path, 'org.bluez.GattCharacteristic1','UUID')

        if self.uuid in gatt_list:
            self.entry = gatt_list[self.uuid]
            self.known = 1
        else:
            self.entry = gatt_list['unknown']
            self.known = 0

    def desc(self):
        return self.entry['desc']

    def read(self):
        value = self.char.ReadValue({'none': 0})
        return self.entry['func'](value)

    def device_path(self):
        """Follow the pointers in the objects to find the parent device
        """
        service_path = self.prop.Get(self.path, 'org.bluez.GattCharacteristic1','Service')
        device_path = self.prop.Get(service_path, 'org.bluez.GattService1','Device')
        return device_path

    def device(self,bus):
        return Device(bus,self.prop,self.device_path())


class Device:
    """Representing a bluetooth device
    """

    def __init__(self, bus, prop, path):
        # FIXME - there should only be one instance for any path, we should
        # keep a class dictionary and return refs to existing objects
        # if found

        self.path = path
        self.prop = prop

        proxy = bus.get_object('org.bluez',path)
        self.dev = dbus.Interface(proxy,
                              dbus_interface="org.bluez.Device1")

        # properties that will not change
        self.address = self.prop.Get(self.path,'org.bluez.Device1','Address')
        self.name = self.prop.Get(self.path,'org.bluez.Device1','Alias')
        self.uuids = self.prop.Get(self.path,'org.bluez.Device1','UUIDs')

    def connected(self):
        return self.prop.Get(self.path,'org.bluez.Device1','Connected')

    def servicesresolved(self):
        return self.prop.Get(self.path,'org.bluez.Device1','ServicesResolved')

    def Connect(self):
        try:
            self.dev.Connect()
        except dbus.exceptions.DBusException as e:
            print "Error: {}".format(e)
            return None
        else:
            self.prop.invalidate()
            return 1


class PropertyCache:
    """Keep a cache of the managed objects
    """
    # Theoretically, I could listen for signals and keep a local model of
    # the properties updated with that.  But that would need an event loop
    # and (I think) more complextiy
    #
    # TODO - this is a hacky singleton, investigate python best practices

    def __init__(self, bus):
        # TODO: do we care that this hardcodes the destination on what is
        # a generic call?
        proxy = bus.get_object('org.bluez','/')

        self.manager = dbus.Interface(proxy,
                          dbus_interface="org.freedesktop.DBus.ObjectManager")
        self.valid = 0

    def _validate(self):
        """Ensure that the cache is currently valid
           This could be a more complex cache validity system, but right
           now, it can simply throw away the whole cache
        """
        if not self.valid:
            self.all_objects = self.manager.GetManagedObjects()
            self.valid = 1

    def invalidate(self):
        self.valid = 0

    def Get(self,path,interface,property):
        self._validate()
        return self.all_objects[path][interface][property]

    def interface2paths(self,interface):
        """Return the set of all paths that have the given interface
        """
        self._validate()
        result = set()
        for path, interfaces in self.all_objects.iteritems():
            if interface in interfaces:
                result.add(path)
        return result


def list_devices(bus,prop):
    devices = prop.interface2paths('org.bluez.Device1')
    for path in devices:
        device = Device(bus,prop,path)

        if device.name is not None:
            name = device.name
        else:
            name = "\N"
        print "{} {} Connected={} ServicesResolved={}".format(
            device.address, name, device.connected(),device.servicesresolved()
        )
        for uuid in device.uuids:
            print "\t",uuid


def main(args):
    """ TODO:
        - note that this only works after bluetoothctl has configured and
          connected to the device
    """
    bus = dbus.SystemBus()

    prop = PropertyCache(bus)

    # If a device is already connected, we probably already have
    # the services.  If it is not connected, bluez might have a cached
    # copy of the services.  If neither applies, connect to the
    # device (which I believe will trigger a service resolve)
    devices = prop.interface2paths('org.bluez.Device1')
    device_list = []

    # first, build the list of devices we need to hit
    for path in devices:
        device = Device(bus,prop,path)
        if not device.connected() and not device.servicesresolved():
            device_list.append(device)

    # then try to connect to them (and thus invalidate their properties)
    new_device_list = []
    for device in device_list:
        print "Connecting", device.path
        connected = device.Connect()
        if connected:
            new_device_list.append(device)
    device_list = new_device_list

    # for each device that seemed to connect, wait for its services
    while device_list:
        time.sleep(1)
        prop.invalidate()
        new_device_list = []
        for device in device_list:
            if not device.servicesresolved():
                print "Waiting for ServicesResolved from", device.path
                new_device_list.append(device)
        device_list = new_device_list
        print

    if args.verbose:
        list_devices(bus,prop)
        print

    tree = {}

    # first, create a hit list of all the characteristics we want
    all_gatt = prop.interface2paths('org.bluez.GattCharacteristic1')
    for path in all_gatt:
        object = Characteristic(bus,prop,path)

        if args.verbose>2:
            print "Found",object.path
            print " UUID",object.uuid

        if not object.known:
            continue

        device = object.device(bus)
        if device.path not in tree:
            tree[device.path] = {}

        tree[device.path][object.path] = object

    # confirm that all the devices are connected
    for device_path in tree:
        device = Device(bus,prop,device_path)

        # try to ensure that this device is still connected
        if not device.connected():
            print " Connecting", device.path
            if not device.Connect():
                # we failed the connection, delete this device
                print "  Failed"
                tree.pop(device.path)

    # finally, walk the tree
    for device_path,chars in tree.iteritems():
        device = Device(bus,prop,device_path)
        print "Device",device.address
        for char_path, object in chars.iteritems():
            if args.verbose:
                print " Path",object.path

            if args.verbose>1:
                print " UUID",object.uuid

            print "  {} = {}".format(object.desc(),object.read())


def do_options():
    a = argparse.ArgumentParser('Explore Blootooth Low Energy devices')
    a.add_argument('-v','--verbose', action='count', default=0)

    return a.parse_args()


if __name__ == '__main__':
    args = do_options()
    main(args)

#!/usr/bin/env python
#
# Simple test script to try and interact with BLE devices
#

import argparse

import dbus
import struct
import time

def dbus2float32t(array):
    """Dbus returns us a "dbus.Array", we want the float from inside that
    """
    s = ''
    for ch in array:
        s += chr(ch)
    return (struct.unpack('<f',s))[0]

def dbus2uint8t(array):
    return int(array[0])

def dbus2unknown(object):
    return object

gatt_list = {
    'unknown': {
        'func': dbus2unknown,
        'desc': 'Unknown',
    },
    '00002a19-0000-1000-8000-00805f9b34fb': {
        'func': dbus2uint8t,
        'desc': 'Battery',
    },
    '00002235-b38d-4985-720e-0f993a68ee41': {
        'func': dbus2float32t,
        'desc': 'Temperature',
    },
    '00001235-b38d-4985-720e-0f993a68ee41': {
        'func': dbus2float32t,
        'desc': 'Humidity',
    },
}


class Characteristic:
    def __init__(self, bus, path):
        self.bus = bus
        self.path = path

        proxy = self.bus.get_object('org.bluez',path)

        self.char = dbus.Interface(proxy,
                              dbus_interface="org.bluez.GattCharacteristic1")
        self.prop = dbus.Interface(proxy,
                              dbus_interface="org.freedesktop.DBus.Properties")

        self.uuid = self.prop.Get('org.bluez.GattCharacteristic1','UUID')

        if self.uuid in gatt_list:
            self.entry = gatt_list[self.uuid]
            self.known = 1
        else:
            self.entry = gatt_list['unknown']
            self.known = 0

    def desc(self):
        return self.entry['desc']

    def read(self):
        value = self.char.ReadValue({'none': 0})
        return self.entry['func'](value)


def list_paths(objects,interface):
    result = {}
    for path, interfaces in objects.iteritems():
        if interface in interfaces:
            result[path] = interfaces
    return result


def list_devices(all_objects):
    btdevices = list_paths(all_objects,'org.bluez.Device1')
    for path, interface in btdevices.iteritems():
        props = interface['org.bluez.Device1']
        address = props['Address']
        if 'Name' in props:
            name = props['Name']
        else:
            name = "\N"
        print "{} {} Connected={} ServicesResolved={}".format(
            address, name, props['Connected'],props['ServicesResolved']
        )
        for uuid in props['UUIDs']:
            print "\t",uuid


def gattchar2devicepath(all_objects, gattcharpath):
    """Follow the pointers in the objects dictionary to find the parent
       device, given the gatt characteristic path
    """
    gattchar = all_objects[gattcharpath]['org.bluez.GattCharacteristic1']
    service_path = gattchar['Service']
    servicechar = all_objects[service_path]['org.bluez.GattService1']
    device_path = servicechar['Device']
    return device_path

def get_all_objects(proxy):
    """Get a new cache of all the managed objects and their properties
    """
    all_objects = dbus.Interface(proxy, "org.freedesktop.DBus.ObjectManager").GetManagedObjects()
    return all_objects


def main(args):
    """ TODO:
        - note that this only works after bluetoothctl has configured and
          connected to the device
    """
    bus_name="org.bluez"
    bus = dbus.SystemBus()

    bluez = bus.get_object(bus_name,'/')
    all_objects = get_all_objects(bluez)

    # If a device is already connected, we probably already have
    # the services.  If it is not connected, bluez might have a cached
    # copy of the services.  If neither applies, connect to the
    # device (which I believe will trigger a service resolve)
    all_devices = list_paths(all_objects,'org.bluez.Device1')
    device_connect = 0
    device_list = []
    for path, interface in all_devices.iteritems():
        prop = interface['org.bluez.Device1']
        if not prop['Connected'] and not prop['ServicesResolved']:
            print "Connecting", path
            device = dbus.Interface(bus.get_object(bus_name,path),
                        dbus_interface="org.bluez.Device1")

            try:
                device.Connect()
            except dbus.exceptions.DBusException as e:
                print "Error: {}".format(e)
            else:
                device_connect = 1
                device_list.append(path)

    # if we needed a connect, then we need to loop waiting for services
    while device_list:
        time.sleep(1)
        all_objects = get_all_objects(bluez)
        new_device_list = []
        for device in device_list:
            device_prop = dbus.Interface(bus.get_object(bus_name,device),
                            dbus_interface="org.freedesktop.DBus.Properties")
            servicesresolved = device_prop.Get('org.bluez.Device1','ServicesResolved')
            if not servicesresolved:
                print "Waiting for ServicesResolved from", path
                new_device_list.append(device)
        device_list = new_device_list

    # only need to refresh the whole list if we changed something
    if device_connect:
        all_objects = get_all_objects(bluez)

    if args.verbose:
        list_devices(all_objects)
        print

    all_gatt = list_paths(all_objects,'org.bluez.GattCharacteristic1')
    for path, interface in all_gatt.iteritems():
        object = Characteristic(bus,path)

        if not object.known:
            if args.verbose>2:
                print "Path",object.path
                print " UUID",object.uuid
            continue

        # get this value
        print "Path",object.path

        if args.verbose>1:
            print " UUID",object.uuid

        device_path = gattchar2devicepath(all_objects, object.path)

        # use the cached property
        connected = all_objects[device_path]['org.bluez.Device1']['Connected']

        # try to ensure that this device is still connected
        skipping=0
        if not connected:
            print " Connecting"
            device = dbus.Interface(bus.get_object(bus_name,device_path),
                        dbus_interface="org.bluez.Device1")
            try:
                device.Connect()
            except dbus.exceptions.DBusException as e:
                print "Error: {}".format(e)
                skipping=1

        if skipping:
            print "  \N"
        else:
            print "  {} = {}".format(object.desc(),object.read())


def do_options():
    a = argparse.ArgumentParser('Explore Blootooth Low Energy devices')
    a.add_argument('-v','--verbose', action='count', default=0)

    return a.parse_args()


if __name__ == '__main__':
    args = do_options()
    main(args)

#!/usr/bin/env python
#
# Use the strange sensirion notify protocol to dump the internal log from these
# temperature/humidity sensors

# TODO
# - determine when the data dump is complete and optionally exit
# - find holes in the recieved data dump and re-request the missing parts
# - create an object model for the sensirion device and clean up most of
#   the spaghetti

import argparse
import dbus

from dbus.glib import DBusGMainLoop
from gi.repository import GLib

import os
import sys

# ungh - a hacky global var
hack_loop = None
hack_quit = None

# Ensure that we look for any modules in our local lib dir.  This allows simple
# testing and development use.  It also does not break the case where the lib
# has been installed properly on the normal sys.path
sys.path.insert(0,
                os.path.join(os.path.dirname(os.path.abspath(__file__)), 'lib')
                )
# I would use site.addsitedir, but it does an append, not insert

import hc.dbus.Property
import hc.bluetooth.GATT
import hc.bluetooth.GATT.Sensirion
import time

def dump_history(device_path, hist):
    print "\n"
    print "#Log for",device_path
    print "#timestamp temperature humidity index"

    missing_completely = 0
    missing_part = 0
    prev = None
    for timestamp in sorted(hist.keys()):
        this = hist[timestamp]
        next = this
        if prev is not None:
            if prev.index-1 != this.index:
                missing = prev.index-1 - this.index
                missing_completely += missing
                print "\n# Missing {} datapoints".format(missing)
                next = None
            elif this.temperature is None or this.humidity is None:
                # we are missing part of this sample
                missing_part += 1

            if prev.temperature is None or prev.humidity is None:
                # see if we need a break - after a string of missing data
                if this.temperature is not None and this.humidity is not None:
                    print "# Missing part data\n"

        print "{} {} {}".format(
            timestamp,
            this,
            this.index,
        )

        prev = next

    print "\n# Missing {} datapoint pairs total".format(missing_completely)
    print "# Missing {} partial datapoints total".format(missing_part)
    # TODO - count the number of measurements with one datatype missing

def glib_runonce(func,*args):
    def runonce(func,*args):
        func(*args)
        return False
    GLib.timeout_add(0,runonce,func,*args)

def cb_regular(device, value):
    print "{} {} {}".format(
        value.timestamp,
        value,
        device.path,
    )

def cb_download(object, values):

    if object._passnr < 5 and object._count < object._total:
        print "# try again"
        do_download(object)
        return

    dump_history(object.path, values)

    if hack_quit is not None:
        hack_loop.quit()

def cb_download_progress(object, index, passnr, count, total):
    print "# {}/{} (pass {}, index {})".format(
        count, total,
        passnr,
        index,
    )

def do_download(dev):
    if not dev.DownloadSetup():
        print '# not connected'
        hack_loop.quit()
        return None

    print '# battery =',dev.battery.read()
    print '# settime =',dev._settime
    print '# min time=',dev._mintime
    print '# max time=',dev._maxtime
    print '# interval=',dev._interval

    print '# timespan=', dev._timespan, '(total=', dev._total,')'

    dev.RegularCallback(cb_regular)
    dev.DownloadCallback(cb_download)
    dev.DownloadProgressCallback(cb_download_progress)

    dev.DownloadGo()


def main():

        # there is something wrong with the max time value
        #if timestamp >= object._maxtime
        #    device['_hist_done'] += 1
        #
        #if device['_hist_done'] > 1:
        #    print "Dump", device['_hist']

    bus = dbus.SystemBus()
    prop = hc.dbus.Property.Cache(bus)

    devs = hc.bluetooth.GATT.Sensirion.Device.all(bus, prop)

    if not devs:
        print '# no devices found'
        hack_loop.quit()
        return None

    for dev in devs:
        d = dev.path

        print '#Found: ',d
        # FIXME - skip devices that are not online!

        do_download(dev)

    print "\n#start dumping"
    return False

def do_options():
    a = argparse.ArgumentParser('Download sensirion')
    a.add_argument('-v','--verbose', action='count', default=0)
    a.add_argument('--downloadonly', default=False, action='store_true',
        help="Turn off real-time measurements - just download the archive" )

    args = a.parse_args()

    return args

if __name__ == '__main__':
    args = do_options()

    DBusGMainLoop (set_as_default=True)
    glib_runonce(main)
    loop = GLib.MainLoop()
    hack_loop = loop
    if args.downloadonly:
        hack_quit = True
    loop.run()


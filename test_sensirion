#!/usr/bin/env python
#
# Use the strange sensirion notify protocol to dump the internal log from these
# temperature/humidity sensors

# TODO
# - determine when the data dump is complete and optionally exit
# - find holes in the recieved data dump and re-request the missing parts
# - create an object model for the sensirion device and clean up most of
#   the spaghetti

import argparse
import dbus

from dbus.glib import DBusGMainLoop
from gi.repository import GLib

import os
import sys

# ungh - a hacky global var
hack_quit = None

# Ensure that we look for any modules in our local lib dir.  This allows simple
# testing and development use.  It also does not break the case where the lib
# has been installed properly on the normal sys.path
sys.path.insert(0,
                os.path.join(os.path.dirname(os.path.abspath(__file__)), 'lib')
                )
# I would use site.addsitedir, but it does an append, not insert

import hc.dbus.Property
import hc.bluetooth.GATT
import hc.bluetooth.GATT.Sensirion
import time

def dump_history(device_path, hist):
    print "\n"
    print "#Log for",device_path
    print "#timestamp temperature humidity"
    for timestamp in sorted(hist.keys()):
        print "{} {} {} {}".format(
            timestamp,
            hist[timestamp],
            hist[timestamp].index,
            device_path,
        )
    print "\n"

def glib_runonce(func,*args):
    def runonce(func,*args):
        func(*args)
        return False
    GLib.timeout_add(0,runonce,func,*args)

def main():
    def dump_signal(*args,**kwargs):
        # assert args[0] == org.bluez.GattCharacteristic1
        if 'Value' not in args[1]:
            return

        object = hc.bluetooth.GATT.Characteristic(bus,prop,kwargs['path'])
        device_path = object.device_path()
        device = devices[device_path]
        now = time.time()

        # FIXME - timeout should be in its own task
        if device['_dumping']:
            if '_dump_timeout' in device and now > device['_dump_timeout']:
                # timed out waiting for the next log dump packet
                print "# timeout was",device['_dump_timeout']
                dump_history(device_path, device['_hist'])
                device['_dumping'] = False

                if hack_quit is not None:
                    hack_quit.quit()

        values = object.raw2value(args[1]['Value'])

        if type(values) == type(hc.bluetooth.GATT.Sensirion.Measurement()):
            # FIXME - need to re-add the deduplication here!
#            if object.desc in device['_prev'] and device['_prev'][object.desc] == value:
#                # skip duplicates
#                return

            # FIXME - need to re-add the glomming of readings together here!
            #   (ie: get two notifies, one for temp, one for humid in same time)
            if object.desc == 'Temperature':
                print "{} {:.2f} \N {}".format(now, values.temperature, object.device_path())
            elif object.desc == 'Humidity':
                print "{} \N {:.2f} {}".format(now, values.humidity, object.device_path())
            else:
                raise ValueError
            return

        if type(values) != type(list()):
            print "#", now, object.desc, values, object.device_path()
            return

        device['_dump_timeout'] = now+2
        index = values[0].index
        print "#", now, '@', index, object.desc, object.device_path()
        for v in values:
            index = v.index
            timestamp = device['_max'] - device['_int']*(index-1)
            if timestamp not in device['_hist']:
                device['_hist'][timestamp] = hc.bluetooth.GATT.Sensirion.Measurement()
            device['_hist'][timestamp] += v

        # there is something wrong with the max time value
        #if timestamp >= device['_max']:
        #    device['_hist_done'] += 1
        #
        #if device['_hist_done'] > 1:
        #    print "Dump", device['_hist']

    wanted = {
        '00001235-b38d-4985-720e-0f993a68ee41': 'humidity',
        '00002235-b38d-4985-720e-0f993a68ee41': 'temperature',
        '0000f235-b38d-4985-720e-0f993a68ee41': 'settime',
        '0000f236-b38d-4985-720e-0f993a68ee41': 'mintime',
        '0000f237-b38d-4985-720e-0f993a68ee41': 'maxtime',
        '0000f238-b38d-4985-720e-0f993a68ee41': 'sendlog',
        '0000f239-b38d-4985-720e-0f993a68ee41': 'interval',
    }
    devices = {}

    bus = dbus.SystemBus()
    prop = hc.dbus.Property.Cache(bus)

    bus.add_signal_receiver(dump_signal,'PropertiesChanged',
                path_keyword='path')

    devs = hc.bluetooth.GATT.Sensirion.Device.all(bus, prop)

    for dev in devs:
        d = dev.path
        devices[d] = {}

        print '#Found: ',d
        # FIXME - skip devices that are not online!

        # the device appears to truncate to seconds internally, match that here
        now = int(time.time())
        dev.settime(now)
        devices[d]['_min'] = dev.mintime.read()
        devices[d]['_max'] = dev.maxtime.read()
        devices[d]['_int'] = dev.interval.read()
        devices[d]['_prev'] = {}
        devices[d]['_hist'] = {}
        devices[d]['_dumping'] = True

        print '# settime =',now
        print '# min time=',devices[d]['_min']
        print '# max time=',devices[d]['_max']
        print '# interval=',devices[d]['_int']

        timespan = devices[d]['_max']-devices[d]['_min']
        print '# timespan=', timespan, '(count=', timespan/devices[d]['_int'],')'

        glib_runonce(dev.humidity.StartNotify)
        glib_runonce(dev.temperature.StartNotify)
        glib_runonce(dev.sendlog.write,1)

    print "\n#start dumping"
    return False

def do_options():
    a = argparse.ArgumentParser('Download sensirion')
    a.add_argument('-v','--verbose', action='count', default=0)
    a.add_argument('--downloadonly', default=True, action='store_true',
        help="Turn off real-time measurements - just download the archive" )

    args = a.parse_args()

    return args

if __name__ == '__main__':
    args = do_options()

    DBusGMainLoop (set_as_default=True)
    glib_runonce(main)
    loop = GLib.MainLoop()
    if args.downloadonly:
        hack_quit = loop
    loop.run()

